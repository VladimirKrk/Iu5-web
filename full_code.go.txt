

// =====================================================================================
// FILE: cmd/lab1/main.go
// =====================================================================================

package main

import (
	"Iu5-web/internal/app/config"
	"Iu5-web/internal/app/dsn"
	"Iu5-web/internal/app/handler"
	"Iu5-web/internal/app/repository"
	"Iu5-web/internal/pkg"
	"os"

	"github.com/gin-gonic/gin"
	"github.com/minio/minio-go/v7"
	"github.com/minio/minio-go/v7/pkg/credentials"
	"github.com/sirupsen/logrus"
)

func main() {
	logrus.Info("Application start")

	conf, err := config.NewConfig()
	if err != nil {
		logrus.Fatal(err)
	}

	repo, err := repository.New(dsn.FromEnv())
	if err != nil {
		logrus.Fatal(err)
	}

	endpoint := os.Getenv("MINIO_ENDPOINT")
	accessKeyID := os.Getenv("MINIO_ACCESS_KEY")
	secretAccessKey := os.Getenv("MINIO_SECRET_KEY")
	useSSL := false // Мы работаем локально без HTTPS

	minioClient, err := minio.New(endpoint, &minio.Options{
		Creds:  credentials.NewStaticV4(accessKeyID, secretAccessKey, ""),
		Secure: useSSL,
	})
	if err != nil {
		logrus.Fatalf("ошибка инициализации Minio: %v", err)
	}
	logrus.Info("Minio client initialized")

	hand := handler.NewHandler(repo, minioClient)

	router := gin.Default()
	application := pkg.New(conf, router, hand)
	application.Run()

	logrus.Info("Application terminated")
}


// =====================================================================================
// FILE: cmd/migrate/main.go
// =====================================================================================

package main

import (
	"Iu5-web/internal/app/config"
	"Iu5-web/internal/app/dsn"
	"Iu5-web/internal/app/handler"
	"Iu5-web/internal/app/repository"
	"Iu5-web/internal/pkg"
	"os"

	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
	"github.com/minio/minio-go/v7"
	"github.com/minio/minio-go/v7/pkg/credentials"
	"github.com/sirupsen/logrus"
)

func main() {
	logrus.Info("Application start")

	// Загружаем .env файл
	if err := godotenv.Load(); err != nil {
		logrus.Warn("не удалось загрузить .env файл")
	}

	conf, err := config.NewConfig()
	if err != nil {
		logrus.Fatalf("ошибка конфига: %v", err)
	}

	repo, err := repository.New(dsn.FromEnv())
	if err != nil {
		logrus.Fatalf("ошибка репозитория: %v", err)
	}

	// --- ПОДКЛЮЧЕНИЕ К MINIO ---
	endpoint := os.Getenv("MINIO_ENDPOINT")
	accessKeyID := os.Getenv("MINIO_ACCESS_KEY")
	secretAccessKey := os.Getenv("MINIO_SECRET_KEY")
	useSSL := false

	minioClient, err := minio.New(endpoint, &minio.Options{
		Creds:  credentials.NewStaticV4(accessKeyID, secretAccessKey, ""),
		Secure: useSSL,
	})
	if err != nil {
		logrus.Fatalf("ошибка инициализации Minio: %v", err)
	}
	logrus.Info("Minio client initialized")

	// Передаем Minio-клиент в обработчики
	hand := handler.NewHandler(repo, minioClient)

	router := gin.Default()
	application := pkg.New(conf, router, hand)
	application.Run()

	logrus.Info("Application terminated")
}


// =====================================================================================
// FILE: internal/app/config/config.go
// =====================================================================================

package config

import (
	"github.com/spf13/viper"
)

// Config хранит конфигурацию всего приложения
type Config struct {
	ServiceHost string
	ServicePort int
}

// NewConfig читает конфигурацию из файла config.toml
func NewConfig() (*Config, error) {
	// Указываем Viper, где искать и как называется наш конфиг
	viper.SetConfigName("config")   // имя файла без расширения
	viper.SetConfigType("toml")     // расширение
	viper.AddConfigPath("./config") // папка, где лежит файл

	// Читаем файл
	if err := viper.ReadInConfig(); err != nil {
		return nil, err
	}

	// Создаем пустой объект конфига и "распаковываем" в него данные из файла
	cfg := &Config{}
	if err := viper.Unmarshal(cfg); err != nil {
		return nil, err
	}

	return cfg, nil
}


// =====================================================================================
// FILE: internal/app/ds/CalculateOutput.go
// =====================================================================================

package ds

import (
	"fmt"
)

func CalculateProductionOutput(foundDefects int) string {
	const (
		DefectiveRate = 0.3
		FoundRate     = 0.06
	)

	// Расчет выпуск
	calculatedOutput := float64(foundDefects) / (DefectiveRate * FoundRate)

	// Получаем целое число
	calculatedOutputInt := int(calculatedOutput)

	return fmt.Sprintf("%d шт.", calculatedOutputInt)
}


// =====================================================================================
// FILE: internal/app/ds/User.go
// =====================================================================================

package ds

// представляет таблицу users
type User struct {
	ID          uint   `gorm:"primaryKey"`
	Login       string `gorm:"type:varchar(50);unique;not null"`
	Password    string `gorm:"type:varchar(255);not null"`
	IsModerator bool   `gorm:"default:false"`
}

// Указываем GORM, что эта структура соответствует таблице 'users'
func (u User) TableName() string {
	return "users"
}


// =====================================================================================
// FILE: internal/app/ds/Workshop.go
// =====================================================================================

package ds

type Workshop struct {
	ID            uint   `gorm:"primaryKey"`
	Name          string `gorm:"type:varchar(255);not null"`
	Description   string `gorm:"type:text"`
	Century       string `gorm:"type:varchar(50)"`
	ImageKey      string `gorm:"type:varchar(255)"`
	ExtraImageKey string `gorm:"type:varchar(255)"`
	IsDeleted     bool   `gorm:"default:false"`
}

func (w Workshop) TableName() string { return "workshops" }


// =====================================================================================
// FILE: internal/app/ds/WorkshopApplication.go
// =====================================================================================

package ds

import "time"

type WorkshopApplication struct {
	ID             uint      `gorm:"primaryKey"`
	Status         string    `gorm:"type:varchar(50);not null"`
	CreatedAt      time.Time `gorm:"not null"`
	CreatorID      uint      `gorm:"not null"`
	FormedAt       *time.Time
	CompletedAt    *time.Time
	ModeratorID    *uint
	Creator        User                 `gorm:"foreignKey:CreatorID"`
	Moderator      User                 `gorm:"foreignKey:ModeratorID"`
	Items          []WorkshopProduction `gorm:"foreignKey:ApplicationID"`
	ProductionName string               `gorm:"type:varchar(255)"`
}

func (wa WorkshopApplication) TableName() string { return "workshop_applications" }


// =====================================================================================
// FILE: internal/app/ds/WorkshopProduction.go
// =====================================================================================

package ds

type WorkshopProduction struct {
	ID              uint `gorm:"primaryKey"`
	ApplicationID   uint `gorm:"not null;uniqueIndex:idx_app_workshop"`
	WorkshopID      uint `gorm:"not null;uniqueIndex:idx_app_workshop"`
	FoundDefects    int
	PredictedOutput string `gorm:"type:varchar(255)"`

	Application WorkshopApplication `gorm:"foreignKey:ApplicationID"`
	Workshop    Workshop            `gorm:"foreignKey:WorkshopID"`
}

func (wp WorkshopProduction) TableName() string {
	return "workshop_production"
}


// =====================================================================================
// FILE: internal/app/dsn/dsn.go
// =====================================================================================

package dsn

import (
	"fmt"
	"os"

	"github.com/joho/godotenv"
	"github.com/sirupsen/logrus"
)

// FromEnv читает переменные окружения из .env файла и формирует DSN строку
func FromEnv() string {
	// Загружаем переменные из .env файла в окружение
	if err := godotenv.Load(); err != nil {
		logrus.Warn("не удалось загрузить .env файл, используются системные переменные окружения")
	}

	host := os.Getenv("DB_HOST")
	port := os.Getenv("DB_PORT")
	user := os.Getenv("DB_USER")
	pass := os.Getenv("DB_PASS")
	dbname := os.Getenv("DB_NAME")

	// Формируем DSN строку
	// Пример: "host=localhost port=5432 user=user_workshop password=password_workshop dbname=workshop_db sslmode=disable"
	return fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
		host, port, user, pass, dbname)
}


// =====================================================================================
// FILE: internal/app/handler/handler.go
// =====================================================================================

package handler

import (
	"Iu5-web/internal/app/ds"
	"Iu5-web/internal/app/repository"
	"context"
	"errors"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/minio/minio-go/v7"
	"github.com/sirupsen/logrus"
	"gorm.io/gorm"
)

const currentUserID = 1

type Handler struct {
	Repository  *repository.Repository
	MinioClient *minio.Client
}

func NewHandler(r *repository.Repository, mc *minio.Client) *Handler {
	return &Handler{
		Repository:  r,
		MinioClient: mc,
	}
}

//Workshops

func (h *Handler) GetWorkshops(c *gin.Context) {
	workshops, err := h.Repository.GetWorkshops(c.Query("name"))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, workshops)
}

func (h *Handler) GetWorkshopByID(c *gin.Context) {
	id, _ := strconv.Atoi(c.Param("id"))
	workshop, err := h.Repository.GetWorkshopByID(uint(id))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "мастерская не найдена"})
		return
	}
	c.JSON(http.StatusOK, workshop)
}

func (h *Handler) CreateWorkshop(c *gin.Context) {
	var workshop ds.Workshop
	if err := c.ShouldBindJSON(&workshop); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "неверные входные данные: " + err.Error()})
		return
	}
	if err := h.Repository.CreateWorkshop(&workshop); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось создать мастерскую"})
		return
	}
	c.JSON(http.StatusCreated, workshop)
}

// PUT /api/workshops/:id
func (h *Handler) UpdateWorkshop(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "неверный id"})
		return
	}
	// Сначала находим существующую мастерскую, чтобы убедиться, что она есть
	workshop, err := h.Repository.GetWorkshopByID(uint(id))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "мастерская не найдена"})
		return
	}
	// Парсим JSON из тела запроса поверх существующего объекта
	if err := c.ShouldBindJSON(&workshop); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "неверные входные данные"})
		return
	}
	// GORM метод Save обновит все поля, включая измененные
	if err := h.Repository.UpdateWorkshop(&workshop); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось обновить мастерскую"})
		logrus.Error(err)
		return
	}
	c.JSON(http.StatusOK, workshop)
}

// DELETE /api/workshops/:id
func (h *Handler) DeleteWorkshop(c *gin.Context) {
	id, _ := strconv.Atoi(c.Param("id"))
	workshop, err := h.Repository.GetWorkshopByID(uint(id))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "мастерская не найдена для удаления"})
		return
	}
	if err := h.Repository.DeleteWorkshop(uint(id)); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось удалить мастерскую"})
		return
	}
	//работаем с минио для удаления изображения
	bucketName := os.Getenv("MINIO_BUCKET_NAME")
	if workshop.ImageKey != "" {
		_ = h.MinioClient.RemoveObject(context.Background(), bucketName, workshop.ImageKey, minio.RemoveObjectOptions{})
	}
	if workshop.ExtraImageKey != "" {
		_ = h.MinioClient.RemoveObject(context.Background(), bucketName, workshop.ExtraImageKey, minio.RemoveObjectOptions{})
	}

	c.Status(http.StatusNoContent)
}

func (h *Handler) UploadWorkshopImage(c *gin.Context) {
	id, _ := strconv.Atoi(c.Param("id"))
	workshop, err := h.Repository.GetWorkshopByID(uint(id))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "мастерская не найдена"})
		return
	}

	bucketName := os.Getenv("MINIO_BUCKET_NAME")

	// Обработка осн. изображения
	file, err := c.FormFile("image")
	if err == nil { // Если файл с ключом 'image' пришел
		// Удаляем старый файл
		if workshop.ImageKey != "" {
			_ = h.MinioClient.RemoveObject(context.Background(), bucketName, workshop.ImageKey, minio.RemoveObjectOptions{})
		}
		// Загружаем новый
		imageKey := uuid.New().String() + filepath.Ext(file.Filename)
		fileContent, _ := file.Open()
		defer fileContent.Close()
		_, err = h.MinioClient.PutObject(context.Background(), bucketName, imageKey, fileContent, file.Size, minio.PutObjectOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось загрузить основное изображение"})
			return
		}
		workshop.ImageKey = imageKey
	}

	// обработка доп изображения
	extraFile, err := c.FormFile("extra_image")
	if err == nil { // Если файл с ключом 'extra_image' пришел
		// Удаляем старый файл
		if workshop.ExtraImageKey != "" {
			_ = h.MinioClient.RemoveObject(context.Background(), bucketName, workshop.ExtraImageKey, minio.RemoveObjectOptions{})
		}
		// Загружаем новый
		extraImageKey := uuid.New().String() + filepath.Ext(extraFile.Filename)
		extraFileContent, _ := extraFile.Open()
		defer extraFileContent.Close()
		_, err = h.MinioClient.PutObject(context.Background(), bucketName, extraImageKey, extraFileContent, extraFile.Size, minio.PutObjectOptions{})
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось загрузить дополнительное изображение"})
			return
		}
		workshop.ExtraImageKey = extraImageKey
	}

	if err = h.Repository.UpdateWorkshop(&workshop); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось обновить мастерскую"})
		return
	}

	c.JSON(http.StatusOK, workshop)
}

//Orders

func (h *Handler) GetApplications(c *gin.Context) {
	status := c.Query("status")
	dateFromString, dateToString := c.Query("date_from"), c.Query("date_to")
	var dateFrom, dateTo time.Time
	var err error
	if dateFromString != "" {
		dateFrom, err = time.Parse("2006-01-02", dateFromString)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "неверный формат date_from"})
			return
		}
	}
	if dateToString != "" {
		dateTo, err = time.Parse("2006-01-02", dateToString)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "неверный формат date_to"})
			return
		}
	}
	apps, err := h.Repository.GetApplications(status, dateFrom, dateTo)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось получить заявки"})
		return
	}
	c.JSON(http.StatusOK, apps)
}

func (h *Handler) GetApplicationByID(c *gin.Context) {
	id, _ := strconv.Atoi(c.Param("id"))
	app, err := h.Repository.GetApplicationByID(uint(id))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "заявка не найдена"})
		return
	}
	if app.Status == "удалён" || app.CreatorID != currentUserID {
		c.JSON(http.StatusNotFound, gin.H{"error": "заявка не найдена или нет доступа"})
		return
	}
	c.JSON(http.StatusOK, app)
}

func (h *Handler) UpdateApplication(c *gin.Context) {
	id, _ := strconv.Atoi(c.Param("id"))
	var updateData struct {
		ProductionName string `json:"production_name"`
	}
	if err := c.ShouldBindJSON(&updateData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "неверные входные данные"})
		return
	}
	app, err := h.Repository.GetApplicationByID(uint(id))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "заявка не найдена"})
		return
	}
	if app.CreatorID != currentUserID || app.Status != "черновик" {
		c.JSON(http.StatusForbidden, gin.H{"error": "нет прав для изменения этой заявки"})
		return
	}
	app.ProductionName = updateData.ProductionName
	if err := h.Repository.UpdateApplication(&app); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось обновить заявку"})
		return
	}
	c.JSON(http.StatusOK, app)
}

func (h *Handler) FormApplication(c *gin.Context) {
	id, _ := strconv.Atoi(c.Param("id"))
	app, err := h.Repository.GetApplicationByID(uint(id))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "заявка не найдена"})
		return
	}
	if app.CreatorID != currentUserID || app.Status != "черновик" {
		c.JSON(http.StatusForbidden, gin.H{"error": "можно сформировать только свой черновик"})
		return
	}
	if len(app.Items) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "нельзя сформировать пустую заявку"})
		return
	}
	app.Status = "сформирован"
	now := time.Now()
	app.FormedAt = &now
	if err := h.Repository.UpdateApplication(&app); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось сформировать заявку"})
		return
	}
	c.JSON(http.StatusOK, app)
}

func (h *Handler) CompleteApplication(c *gin.Context) {
	id, _ := strconv.Atoi(c.Param("id"))
	app, err := h.Repository.GetApplicationByID(uint(id))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "заявка не найдена"})
		return
	}
	if app.Status != "сформирован" {
		c.JSON(http.StatusForbidden, gin.H{"error": "можно завершить только сформированную заявку"})
		return
	}

	// Вызываем формулу расчета
	for i, item := range app.Items {
		app.Items[i].PredictedOutput = ds.CalculateProductionOutput(item.FoundDefects)
		if err := h.Repository.UpdateApplicationItem(&app.Items[i]); err != nil {
			logrus.Error("не удалось обновить позицию заказа: ", err)
		}
	}

	app.Status = "завершён"
	now := time.Now()
	app.CompletedAt = &now
	// moderatorID := 2 // ID модератора, в реальном приложении из токена
	// app.ModeratorID = &moderatorID
	if err := h.Repository.UpdateApplication(&app); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось завершить заявку"})
		return
	}
	c.JSON(http.StatusOK, app)
}

func (h *Handler) DeleteApplication(c *gin.Context) {
	id, _ := strconv.Atoi(c.Param("id"))
	err := h.Repository.DeleteApplicationLogically(uint(id), currentUserID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "заявка не найдена или нет прав"})
		return
	}
	c.Status(http.StatusNoContent)
}

//Cart

func (h *Handler) GetCartIcon(c *gin.Context) {
	draftApp, _ := h.Repository.FindOrCreateDraftApplication(currentUserID)
	itemCount, _ := h.Repository.GetDraftApplicationItemCount(currentUserID)
	c.JSON(http.StatusOK, gin.H{
		"application_id": draftApp.ID,
		"item_count":     itemCount,
	})
}

func (h *Handler) AddWorkshopToCart(c *gin.Context) {
	workshopID, _ := strconv.Atoi(c.PostForm("workshop_id"))
	draftApp, _ := h.Repository.FindOrCreateDraftApplication(currentUserID)
	item, err := h.Repository.AddWorkshopToApplication(draftApp.ID, uint(workshopID))
	if err != nil {
		if strings.Contains(err.Error(), "unique constraint") {
			c.JSON(http.StatusConflict, gin.H{"error": "эта мастерская уже в заявке"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось добавить в заявку"})
		return
	}
	c.JSON(http.StatusCreated, item)
}

func (h *Handler) UpdateCartItem(c *gin.Context) {
	var updateData struct {
		WorkshopID      uint   `json:"workshop_id"`
		FoundDefects    int    `json:"found_defects"`
		PredictedOutput string `json:"predicted_output"`
	}
	if err := c.ShouldBindJSON(&updateData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "неверные входные данные"})
		return
	}
	draftApp, _ := h.Repository.FindOrCreateDraftApplication(currentUserID)
	item, err := h.Repository.GetApplicationItem(draftApp.ID, updateData.WorkshopID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "товар в корзине не найден"})
		return
	}
	item.FoundDefects = updateData.FoundDefects
	item.PredictedOutput = updateData.PredictedOutput
	if err := h.Repository.UpdateApplicationItem(&item); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось обновить товар"})
		return
	}
	c.JSON(http.StatusOK, item)
}

func (h *Handler) DeleteCartItem(c *gin.Context) {
	var deleteData struct {
		WorkshopID uint `json:"workshop_id"`
	}
	if err := c.ShouldBindJSON(&deleteData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "неверные входные данные"})
		return
	}
	draftApp, _ := h.Repository.FindOrCreateDraftApplication(currentUserID)
	if err := h.Repository.DeleteApplicationItem(draftApp.ID, deleteData.WorkshopID); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось удалить товар"})
		return
	}
	c.Status(http.StatusNoContent)
}

// User

// POST /api/register
func (h *Handler) RegisterUser(c *gin.Context) {
	var user ds.User
	if err := c.ShouldBindJSON(&user); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "неверные входные данные"})
		return
	}

	// Валидация
	if user.Login == "" || user.Password == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "логин и пароль обязательны для заполнения"})
		return
	}

	if err := h.Repository.CreateUser(&user); err != nil {
		if strings.Contains(err.Error(), "unique constraint") {
			c.JSON(http.StatusConflict, gin.H{"error": "пользователь с таким логином уже существует"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось зарегистрировать пользователя"})
		return
	}

	user.Password = "" // Никогда не возвращаем пароль
	c.JSON(http.StatusCreated, user)
}

// POST /api/login
func (h *Handler) AuthenticateUser(c *gin.Context) {
	var loginData struct {
		Login    string `json:"login"`
		Password string `json:"password"`
	}
	if err := c.ShouldBindJSON(&loginData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "неверные входные данные"})
		return
	}

	user, err := h.Repository.GetUserByLogin(loginData.Login)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "неверный логин или пароль"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "ошибка сервера"})
		return
	}

	if user.Password != loginData.Password {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "неверный логин или пароль"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Аутентификация прошла успешно",
		"token":   "fake-jwt-token-for-" + user.Login,
	})
}

// GET /api/users/me
func (h *Handler) GetUserMe(c *gin.Context) {
	// Используем "захардкоженный" ID, как того требует методичка
	user, err := h.Repository.GetUserByID(currentUserID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "пользователь не найден"})
		return
	}

	user.Password = ""
	c.JSON(http.StatusOK, user)
}

// PUT /api/users/me
func (h *Handler) UpdateUserMe(c *gin.Context) {
	var updateData ds.User
	if err := c.ShouldBindJSON(&updateData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "неверные входные данные"})
		return
	}

	user, err := h.Repository.GetUserByID(currentUserID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "пользователь не найден"})
		return
	}

	// Обновляем только те поля, которые можно менять
	user.Login = updateData.Login
	// В реальном приложении пароль бы обновлялся отдельно и с хешированием
	if updateData.Password != "" {
		user.Password = updateData.Password
	}

	if err := h.Repository.UpdateUser(&user); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "не удалось обновить профиль"})
		return
	}

	user.Password = ""
	c.JSON(http.StatusOK, user)
}

// POST /api/logout (заглушка)
func (h *Handler) DeauthorizeUser(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{"message": "Деавторизация прошла успешно"})
}


// =====================================================================================
// FILE: internal/app/repository/repository.go
// =====================================================================================

package repository

import (
	"Iu5-web/internal/app/ds"
	"log"
	"os"
	"time"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

const MINIO_URL = "http://localhost:9000/vlk-images/"

type Repository struct {
	db *gorm.DB
}

func New(dsn string) (*Repository, error) {
	newLogger := logger.New(
		log.New(os.Stdout, "\r\n", log.LstdFlags),
		logger.Config{
			SlowThreshold: time.Second,
			LogLevel:      logger.Info,
			Colorful:      true,
		},
	)
	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{Logger: newLogger})
	if err != nil {
		return nil, err
	}
	return &Repository{db: db}, nil
}

// Методы для Мастерских (Workshops)
func (r *Repository) GetWorkshops(name string) ([]ds.Workshop, error) {
	var workshops []ds.Workshop
	query := r.db.Where("is_deleted = ?", false)
	if name != "" {
		query = query.Where("name ILIKE ?", "%"+name+"%")
	}
	err := query.Find(&workshops).Error
	return workshops, err
}

func (r *Repository) GetWorkshopByID(id uint) (ds.Workshop, error) {
	var workshop ds.Workshop
	err := r.db.First(&workshop, id).Error
	return workshop, err
}

func (r *Repository) CreateWorkshop(workshop *ds.Workshop) error {
	return r.db.Create(workshop).Error
}

func (r *Repository) UpdateWorkshop(workshop *ds.Workshop) error {
	return r.db.Save(workshop).Error
}

func (r *Repository) DeleteWorkshop(id uint) error {
	return r.db.Delete(&ds.Workshop{}, id).Error
}

// Методы для Заказов (Applications/Orders)
func (r *Repository) GetApplications(status string, dateFrom, dateTo time.Time) ([]ds.WorkshopApplication, error) {
	var apps []ds.WorkshopApplication
	query := r.db.Where("status NOT IN (?, ?)", "черновик", "удалён")
	if status != "" {
		query = query.Where("status = ?", status)
	}
	if !dateFrom.IsZero() && !dateTo.IsZero() {
		query = query.Where("formed_at BETWEEN ? AND ?", dateFrom, dateTo)
	}
	err := query.Preload("Creator").Preload("Moderator").Find(&apps).Error
	return apps, err
}

func (r *Repository) GetApplicationByID(id uint) (ds.WorkshopApplication, error) {
	var app ds.WorkshopApplication
	err := r.db.Preload("Items.Workshop").Preload("Creator").Preload("Moderator").First(&app, id).Error
	return app, err
}

func (r *Repository) FindOrCreateDraftApplication(userID uint) (ds.WorkshopApplication, error) {
	var app ds.WorkshopApplication
	err := r.db.Where("creator_id = ? AND status = ?", userID, "черновик").First(&app).Error
	if err == gorm.ErrRecordNotFound {
		newApp := ds.WorkshopApplication{Status: "черновик", CreatedAt: time.Now(), CreatorID: userID}
		err = r.db.Create(&newApp).Error
		return newApp, err
	}
	return app, err
}

func (r *Repository) UpdateApplication(app *ds.WorkshopApplication) error {
	return r.db.Save(app).Error
}

func (r *Repository) DeleteApplicationLogically(appID, userID uint) error {
	result := r.db.Exec("UPDATE workshop_applications SET status = ? WHERE id = ? AND creator_id = ?", "удалён", appID, userID)
	if result.RowsAffected == 0 {
		return gorm.ErrRecordNotFound
	}
	return result.Error
}

// Методы для Позиций Заказа (Order Items)
func (r *Repository) AddWorkshopToApplication(appID, workshopID uint) (ds.WorkshopProduction, error) {
	item := ds.WorkshopProduction{ApplicationID: appID, WorkshopID: workshopID}
	err := r.db.Create(&item).Error
	return item, err
}

func (r *Repository) GetApplicationItem(appID, workshopID uint) (ds.WorkshopProduction, error) {
	var item ds.WorkshopProduction
	err := r.db.Where("application_id = ? AND workshop_id = ?", appID, workshopID).First(&item).Error
	return item, err
}

func (r *Repository) UpdateApplicationItem(item *ds.WorkshopProduction) error {
	return r.db.Save(item).Error
}

func (r *Repository) DeleteApplicationItem(appID, workshopID uint) error {
	result := r.db.Where("application_id = ? AND workshop_id = ?", appID, workshopID).Delete(&ds.WorkshopProduction{})
	return result.Error
}

func (r *Repository) GetDraftApplicationItemCount(userID uint) (int64, error) {
	var app ds.WorkshopApplication
	err := r.db.Where("creator_id = ? AND status = ?", userID, "черновик").First(&app).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return 0, nil
		}
		return 0, err
	}
	var count int64
	err = r.db.Model(&ds.WorkshopProduction{}).Where("application_id = ?", app.ID).Count(&count).Error
	return count, err
}

// Методы для Пользователей (Users)
func (r *Repository) CreateUser(user *ds.User) error {
	return r.db.Create(user).Error
}

func (r *Repository) GetUserByID(id uint) (ds.User, error) {
	var user ds.User
	err := r.db.First(&user, id).Error
	return user, err
}

// находит пользователя по  логину
func (r *Repository) GetUserByLogin(login string) (ds.User, error) {
	var user ds.User
	err := r.db.Where("login = ?", login).First(&user).Error
	return user, err
}

func (r *Repository) UpdateUser(user *ds.User) error {
	return r.db.Save(user).Error
}


// =====================================================================================
// FILE: internal/pkg/app.go
// =====================================================================================

package pkg

import (
	"Iu5-web/internal/app/config"
	"Iu5-web/internal/app/handler"
	"fmt"

	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
)

type App struct {
	Config  *config.Config
	Router  *gin.Engine
	Handler *handler.Handler
}

func New(c *config.Config, r *gin.Engine, h *handler.Handler) *App {
	return &App{Config: c, Router: r, Handler: h}
}

func (a *App) Run() {
	logrus.Info("Starting server")

	// Группа роутов /api
	api := a.Router.Group("/api")
	{
		// Домен "Мастерские"
		workshops := api.Group("/workshops")
		{
			workshops.GET("", a.Handler.GetWorkshops)
			workshops.GET("/:id", a.Handler.GetWorkshopByID)
			workshops.POST("", a.Handler.CreateWorkshop)
			workshops.PUT("/:id", a.Handler.UpdateWorkshop)
			workshops.DELETE("/:id", a.Handler.DeleteWorkshop)
			workshops.POST("/:id/image", a.Handler.UploadWorkshopImage)
		}

		// Домен "Заказы"
		orders := api.Group("/orders")
		{
			orders.GET("", a.Handler.GetApplications)
			orders.GET("/:id", a.Handler.GetApplicationByID)
			orders.PUT("/:id", a.Handler.UpdateApplication)
			orders.PUT("/:id/form", a.Handler.FormApplication)
			orders.PUT("/:id/complete", a.Handler.CompleteApplication)
			orders.DELETE("/:id", a.Handler.DeleteApplication)
		}

		// Домен "Корзина"
		cart := api.Group("/cart")
		{
			cart.GET("/icon", a.Handler.GetCartIcon)
			cart.POST("/workshops", a.Handler.AddWorkshopToCart)
			cart.PUT("/items", a.Handler.UpdateCartItem)
			cart.DELETE("/items", a.Handler.DeleteCartItem)
		}

		// Домен "Пользователи"
		api.POST("/register", a.Handler.RegisterUser)
		api.GET("/users/me", a.Handler.GetUserMe)
	}

	serverAddress := fmt.Sprintf("%s:%d", a.Config.ServiceHost, a.Config.ServicePort)
	if err := a.Router.Run(serverAddress); err != nil {
		logrus.Fatal(err)
	}
}
